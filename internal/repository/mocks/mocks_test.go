// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/0xpanadol/manga/internal/domain"
	"github.com/0xpanadol/manga/internal/repository"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockChapterRepository creates a new instance of MockChapterRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChapterRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChapterRepository {
	mock := &MockChapterRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChapterRepository is an autogenerated mock type for the ChapterRepository type
type MockChapterRepository struct {
	mock.Mock
}

type MockChapterRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChapterRepository) EXPECT() *MockChapterRepository_Expecter {
	return &MockChapterRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) Create(ctx context.Context, chapter *domain.Chapter) error {
	ret := _mock.Called(ctx, chapter)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Chapter) error); ok {
		r0 = returnFunc(ctx, chapter)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChapterRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockChapterRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - chapter *domain.Chapter
func (_e *MockChapterRepository_Expecter) Create(ctx interface{}, chapter interface{}) *MockChapterRepository_Create_Call {
	return &MockChapterRepository_Create_Call{Call: _e.mock.On("Create", ctx, chapter)}
}

func (_c *MockChapterRepository_Create_Call) Run(run func(ctx context.Context, chapter *domain.Chapter)) *MockChapterRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Chapter
		if args[1] != nil {
			arg1 = args[1].(*domain.Chapter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChapterRepository_Create_Call) Return(err error) *MockChapterRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChapterRepository_Create_Call) RunAndReturn(run func(ctx context.Context, chapter *domain.Chapter) error) *MockChapterRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChapterRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockChapterRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockChapterRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockChapterRepository_Delete_Call {
	return &MockChapterRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockChapterRepository_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockChapterRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChapterRepository_Delete_Call) Return(err error) *MockChapterRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChapterRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockChapterRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.Chapter, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 *domain.Chapter
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Chapter, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Chapter); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Chapter)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChapterRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockChapterRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockChapterRepository_Expecter) FindByID(ctx interface{}, id interface{}) *MockChapterRepository_FindByID_Call {
	return &MockChapterRepository_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id)}
}

func (_c *MockChapterRepository_FindByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockChapterRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChapterRepository_FindByID_Call) Return(chapter *domain.Chapter, err error) *MockChapterRepository_FindByID_Call {
	_c.Call.Return(chapter, err)
	return _c
}

func (_c *MockChapterRepository_FindByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.Chapter, error)) *MockChapterRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// ListByMangaID provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) ListByMangaID(ctx context.Context, params repository.ListChaptersParams) ([]*domain.Chapter, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for ListByMangaID")
	}

	var r0 []*domain.Chapter
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListChaptersParams) ([]*domain.Chapter, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListChaptersParams) []*domain.Chapter); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Chapter)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.ListChaptersParams) error); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockChapterRepository_ListByMangaID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByMangaID'
type MockChapterRepository_ListByMangaID_Call struct {
	*mock.Call
}

// ListByMangaID is a helper method to define mock.On call
//   - ctx context.Context
//   - params repository.ListChaptersParams
func (_e *MockChapterRepository_Expecter) ListByMangaID(ctx interface{}, params interface{}) *MockChapterRepository_ListByMangaID_Call {
	return &MockChapterRepository_ListByMangaID_Call{Call: _e.mock.On("ListByMangaID", ctx, params)}
}

func (_c *MockChapterRepository_ListByMangaID_Call) Run(run func(ctx context.Context, params repository.ListChaptersParams)) *MockChapterRepository_ListByMangaID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.ListChaptersParams
		if args[1] != nil {
			arg1 = args[1].(repository.ListChaptersParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChapterRepository_ListByMangaID_Call) Return(chapters []*domain.Chapter, err error) *MockChapterRepository_ListByMangaID_Call {
	_c.Call.Return(chapters, err)
	return _c
}

func (_c *MockChapterRepository_ListByMangaID_Call) RunAndReturn(run func(ctx context.Context, params repository.ListChaptersParams) ([]*domain.Chapter, error)) *MockChapterRepository_ListByMangaID_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) Update(ctx context.Context, chapter *domain.Chapter) error {
	ret := _mock.Called(ctx, chapter)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Chapter) error); ok {
		r0 = returnFunc(ctx, chapter)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChapterRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockChapterRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - chapter *domain.Chapter
func (_e *MockChapterRepository_Expecter) Update(ctx interface{}, chapter interface{}) *MockChapterRepository_Update_Call {
	return &MockChapterRepository_Update_Call{Call: _e.mock.On("Update", ctx, chapter)}
}

func (_c *MockChapterRepository_Update_Call) Run(run func(ctx context.Context, chapter *domain.Chapter)) *MockChapterRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Chapter
		if args[1] != nil {
			arg1 = args[1].(*domain.Chapter)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChapterRepository_Update_Call) Return(err error) *MockChapterRepository_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChapterRepository_Update_Call) RunAndReturn(run func(ctx context.Context, chapter *domain.Chapter) error) *MockChapterRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePages provides a mock function for the type MockChapterRepository
func (_mock *MockChapterRepository) UpdatePages(ctx context.Context, id uuid.UUID, pages []string) error {
	ret := _mock.Called(ctx, id, pages)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePages")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, []string) error); ok {
		r0 = returnFunc(ctx, id, pages)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChapterRepository_UpdatePages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePages'
type MockChapterRepository_UpdatePages_Call struct {
	*mock.Call
}

// UpdatePages is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
//   - pages []string
func (_e *MockChapterRepository_Expecter) UpdatePages(ctx interface{}, id interface{}, pages interface{}) *MockChapterRepository_UpdatePages_Call {
	return &MockChapterRepository_UpdatePages_Call{Call: _e.mock.On("UpdatePages", ctx, id, pages)}
}

func (_c *MockChapterRepository_UpdatePages_Call) Run(run func(ctx context.Context, id uuid.UUID, pages []string)) *MockChapterRepository_UpdatePages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 []string
		if args[2] != nil {
			arg2 = args[2].([]string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockChapterRepository_UpdatePages_Call) Return(err error) *MockChapterRepository_UpdatePages_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChapterRepository_UpdatePages_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, pages []string) error) *MockChapterRepository_UpdatePages_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMangaRepository creates a new instance of MockMangaRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMangaRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMangaRepository {
	mock := &MockMangaRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMangaRepository is an autogenerated mock type for the MangaRepository type
type MockMangaRepository struct {
	mock.Mock
}

type MockMangaRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMangaRepository) EXPECT() *MockMangaRepository_Expecter {
	return &MockMangaRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockMangaRepository
func (_mock *MockMangaRepository) Create(ctx context.Context, manga *domain.Manga) error {
	ret := _mock.Called(ctx, manga)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Manga) error); ok {
		r0 = returnFunc(ctx, manga)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMangaRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockMangaRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - manga *domain.Manga
func (_e *MockMangaRepository_Expecter) Create(ctx interface{}, manga interface{}) *MockMangaRepository_Create_Call {
	return &MockMangaRepository_Create_Call{Call: _e.mock.On("Create", ctx, manga)}
}

func (_c *MockMangaRepository_Create_Call) Run(run func(ctx context.Context, manga *domain.Manga)) *MockMangaRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Manga
		if args[1] != nil {
			arg1 = args[1].(*domain.Manga)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMangaRepository_Create_Call) Return(err error) *MockMangaRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMangaRepository_Create_Call) RunAndReturn(run func(ctx context.Context, manga *domain.Manga) error) *MockMangaRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockMangaRepository
func (_mock *MockMangaRepository) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMangaRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockMangaRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMangaRepository_Expecter) Delete(ctx interface{}, id interface{}) *MockMangaRepository_Delete_Call {
	return &MockMangaRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockMangaRepository_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMangaRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMangaRepository_Delete_Call) Return(err error) *MockMangaRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMangaRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockMangaRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function for the type MockMangaRepository
func (_mock *MockMangaRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.Manga, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 *domain.Manga
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Manga, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Manga); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Manga)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMangaRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockMangaRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockMangaRepository_Expecter) FindByID(ctx interface{}, id interface{}) *MockMangaRepository_FindByID_Call {
	return &MockMangaRepository_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id)}
}

func (_c *MockMangaRepository_FindByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockMangaRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMangaRepository_FindByID_Call) Return(manga *domain.Manga, err error) *MockMangaRepository_FindByID_Call {
	_c.Call.Return(manga, err)
	return _c
}

func (_c *MockMangaRepository_FindByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.Manga, error)) *MockMangaRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockMangaRepository
func (_mock *MockMangaRepository) List(ctx context.Context, params repository.ListMangaParams) ([]*domain.Manga, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []*domain.Manga
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListMangaParams) ([]*domain.Manga, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListMangaParams) []*domain.Manga); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Manga)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.ListMangaParams) error); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMangaRepository_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockMangaRepository_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
//   - ctx context.Context
//   - params repository.ListMangaParams
func (_e *MockMangaRepository_Expecter) List(ctx interface{}, params interface{}) *MockMangaRepository_List_Call {
	return &MockMangaRepository_List_Call{Call: _e.mock.On("List", ctx, params)}
}

func (_c *MockMangaRepository_List_Call) Run(run func(ctx context.Context, params repository.ListMangaParams)) *MockMangaRepository_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.ListMangaParams
		if args[1] != nil {
			arg1 = args[1].(repository.ListMangaParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMangaRepository_List_Call) Return(mangas []*domain.Manga, err error) *MockMangaRepository_List_Call {
	_c.Call.Return(mangas, err)
	return _c
}

func (_c *MockMangaRepository_List_Call) RunAndReturn(run func(ctx context.Context, params repository.ListMangaParams) ([]*domain.Manga, error)) *MockMangaRepository_List_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockMangaRepository
func (_mock *MockMangaRepository) Update(ctx context.Context, manga *domain.Manga) error {
	ret := _mock.Called(ctx, manga)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Manga) error); ok {
		r0 = returnFunc(ctx, manga)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockMangaRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockMangaRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - manga *domain.Manga
func (_e *MockMangaRepository_Expecter) Update(ctx interface{}, manga interface{}) *MockMangaRepository_Update_Call {
	return &MockMangaRepository_Update_Call{Call: _e.mock.On("Update", ctx, manga)}
}

func (_c *MockMangaRepository_Update_Call) Run(run func(ctx context.Context, manga *domain.Manga)) *MockMangaRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Manga
		if args[1] != nil {
			arg1 = args[1].(*domain.Manga)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockMangaRepository_Update_Call) Return(err error) *MockMangaRepository_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockMangaRepository_Update_Call) RunAndReturn(run func(ctx context.Context, manga *domain.Manga) error) *MockMangaRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSocialRepository creates a new instance of MockSocialRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSocialRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSocialRepository {
	mock := &MockSocialRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSocialRepository is an autogenerated mock type for the SocialRepository type
type MockSocialRepository struct {
	mock.Mock
}

type MockSocialRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSocialRepository) EXPECT() *MockSocialRepository_Expecter {
	return &MockSocialRepository_Expecter{mock: &_m.Mock}
}

// CreateComment provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) CreateComment(ctx context.Context, comment *domain.Comment) error {
	ret := _mock.Called(ctx, comment)

	if len(ret) == 0 {
		panic("no return value specified for CreateComment")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Comment) error); ok {
		r0 = returnFunc(ctx, comment)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSocialRepository_CreateComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateComment'
type MockSocialRepository_CreateComment_Call struct {
	*mock.Call
}

// CreateComment is a helper method to define mock.On call
//   - ctx context.Context
//   - comment *domain.Comment
func (_e *MockSocialRepository_Expecter) CreateComment(ctx interface{}, comment interface{}) *MockSocialRepository_CreateComment_Call {
	return &MockSocialRepository_CreateComment_Call{Call: _e.mock.On("CreateComment", ctx, comment)}
}

func (_c *MockSocialRepository_CreateComment_Call) Run(run func(ctx context.Context, comment *domain.Comment)) *MockSocialRepository_CreateComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Comment
		if args[1] != nil {
			arg1 = args[1].(*domain.Comment)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSocialRepository_CreateComment_Call) Return(err error) *MockSocialRepository_CreateComment_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSocialRepository_CreateComment_Call) RunAndReturn(run func(ctx context.Context, comment *domain.Comment) error) *MockSocialRepository_CreateComment_Call {
	_c.Call.Return(run)
	return _c
}

// ListComments provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) ListComments(ctx context.Context, params repository.ListCommentsParams) ([]*domain.CommentWithUser, error) {
	ret := _mock.Called(ctx, params)

	if len(ret) == 0 {
		panic("no return value specified for ListComments")
	}

	var r0 []*domain.CommentWithUser
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListCommentsParams) ([]*domain.CommentWithUser, error)); ok {
		return returnFunc(ctx, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, repository.ListCommentsParams) []*domain.CommentWithUser); ok {
		r0 = returnFunc(ctx, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.CommentWithUser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, repository.ListCommentsParams) error); ok {
		r1 = returnFunc(ctx, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSocialRepository_ListComments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListComments'
type MockSocialRepository_ListComments_Call struct {
	*mock.Call
}

// ListComments is a helper method to define mock.On call
//   - ctx context.Context
//   - params repository.ListCommentsParams
func (_e *MockSocialRepository_Expecter) ListComments(ctx interface{}, params interface{}) *MockSocialRepository_ListComments_Call {
	return &MockSocialRepository_ListComments_Call{Call: _e.mock.On("ListComments", ctx, params)}
}

func (_c *MockSocialRepository_ListComments_Call) Run(run func(ctx context.Context, params repository.ListCommentsParams)) *MockSocialRepository_ListComments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repository.ListCommentsParams
		if args[1] != nil {
			arg1 = args[1].(repository.ListCommentsParams)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSocialRepository_ListComments_Call) Return(commentWithUsers []*domain.CommentWithUser, err error) *MockSocialRepository_ListComments_Call {
	_c.Call.Return(commentWithUsers, err)
	return _c
}

func (_c *MockSocialRepository_ListComments_Call) RunAndReturn(run func(ctx context.Context, params repository.ListCommentsParams) ([]*domain.CommentWithUser, error)) *MockSocialRepository_ListComments_Call {
	_c.Call.Return(run)
	return _c
}

// ListFavorites provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) ListFavorites(ctx context.Context, userID uuid.UUID, params repository.ListMangaParams) ([]*domain.Manga, error) {
	ret := _mock.Called(ctx, userID, params)

	if len(ret) == 0 {
		panic("no return value specified for ListFavorites")
	}

	var r0 []*domain.Manga
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, repository.ListMangaParams) ([]*domain.Manga, error)); ok {
		return returnFunc(ctx, userID, params)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, repository.ListMangaParams) []*domain.Manga); ok {
		r0 = returnFunc(ctx, userID, params)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Manga)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, repository.ListMangaParams) error); ok {
		r1 = returnFunc(ctx, userID, params)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSocialRepository_ListFavorites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListFavorites'
type MockSocialRepository_ListFavorites_Call struct {
	*mock.Call
}

// ListFavorites is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - params repository.ListMangaParams
func (_e *MockSocialRepository_Expecter) ListFavorites(ctx interface{}, userID interface{}, params interface{}) *MockSocialRepository_ListFavorites_Call {
	return &MockSocialRepository_ListFavorites_Call{Call: _e.mock.On("ListFavorites", ctx, userID, params)}
}

func (_c *MockSocialRepository_ListFavorites_Call) Run(run func(ctx context.Context, userID uuid.UUID, params repository.ListMangaParams)) *MockSocialRepository_ListFavorites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 repository.ListMangaParams
		if args[2] != nil {
			arg2 = args[2].(repository.ListMangaParams)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSocialRepository_ListFavorites_Call) Return(mangas []*domain.Manga, err error) *MockSocialRepository_ListFavorites_Call {
	_c.Call.Return(mangas, err)
	return _c
}

func (_c *MockSocialRepository_ListFavorites_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, params repository.ListMangaParams) ([]*domain.Manga, error)) *MockSocialRepository_ListFavorites_Call {
	_c.Call.Return(run)
	return _c
}

// ListReadChapters provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) ListReadChapters(ctx context.Context, userID uuid.UUID) ([]*domain.Chapter, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for ListReadChapters")
	}

	var r0 []*domain.Chapter
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*domain.Chapter, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*domain.Chapter); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Chapter)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSocialRepository_ListReadChapters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListReadChapters'
type MockSocialRepository_ListReadChapters_Call struct {
	*mock.Call
}

// ListReadChapters is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockSocialRepository_Expecter) ListReadChapters(ctx interface{}, userID interface{}) *MockSocialRepository_ListReadChapters_Call {
	return &MockSocialRepository_ListReadChapters_Call{Call: _e.mock.On("ListReadChapters", ctx, userID)}
}

func (_c *MockSocialRepository_ListReadChapters_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockSocialRepository_ListReadChapters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockSocialRepository_ListReadChapters_Call) Return(chapters []*domain.Chapter, err error) *MockSocialRepository_ListReadChapters_Call {
	_c.Call.Return(chapters, err)
	return _c
}

func (_c *MockSocialRepository_ListReadChapters_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) ([]*domain.Chapter, error)) *MockSocialRepository_ListReadChapters_Call {
	_c.Call.Return(run)
	return _c
}

// MarkChapterAsRead provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) MarkChapterAsRead(ctx context.Context, userID uuid.UUID, chapterID uuid.UUID) error {
	ret := _mock.Called(ctx, userID, chapterID)

	if len(ret) == 0 {
		panic("no return value specified for MarkChapterAsRead")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, userID, chapterID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockSocialRepository_MarkChapterAsRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkChapterAsRead'
type MockSocialRepository_MarkChapterAsRead_Call struct {
	*mock.Call
}

// MarkChapterAsRead is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - chapterID uuid.UUID
func (_e *MockSocialRepository_Expecter) MarkChapterAsRead(ctx interface{}, userID interface{}, chapterID interface{}) *MockSocialRepository_MarkChapterAsRead_Call {
	return &MockSocialRepository_MarkChapterAsRead_Call{Call: _e.mock.On("MarkChapterAsRead", ctx, userID, chapterID)}
}

func (_c *MockSocialRepository_MarkChapterAsRead_Call) Run(run func(ctx context.Context, userID uuid.UUID, chapterID uuid.UUID)) *MockSocialRepository_MarkChapterAsRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 uuid.UUID
		if args[2] != nil {
			arg2 = args[2].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSocialRepository_MarkChapterAsRead_Call) Return(err error) *MockSocialRepository_MarkChapterAsRead_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockSocialRepository_MarkChapterAsRead_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, chapterID uuid.UUID) error) *MockSocialRepository_MarkChapterAsRead_Call {
	_c.Call.Return(run)
	return _c
}

// ToggleFavorite provides a mock function for the type MockSocialRepository
func (_mock *MockSocialRepository) ToggleFavorite(ctx context.Context, userID uuid.UUID, mangaID uuid.UUID) (*repository.ToggleFavoriteResult, error) {
	ret := _mock.Called(ctx, userID, mangaID)

	if len(ret) == 0 {
		panic("no return value specified for ToggleFavorite")
	}

	var r0 *repository.ToggleFavoriteResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) (*repository.ToggleFavoriteResult, error)); ok {
		return returnFunc(ctx, userID, mangaID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) *repository.ToggleFavoriteResult); ok {
		r0 = returnFunc(ctx, userID, mangaID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*repository.ToggleFavoriteResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, userID, mangaID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSocialRepository_ToggleFavorite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ToggleFavorite'
type MockSocialRepository_ToggleFavorite_Call struct {
	*mock.Call
}

// ToggleFavorite is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - mangaID uuid.UUID
func (_e *MockSocialRepository_Expecter) ToggleFavorite(ctx interface{}, userID interface{}, mangaID interface{}) *MockSocialRepository_ToggleFavorite_Call {
	return &MockSocialRepository_ToggleFavorite_Call{Call: _e.mock.On("ToggleFavorite", ctx, userID, mangaID)}
}

func (_c *MockSocialRepository_ToggleFavorite_Call) Run(run func(ctx context.Context, userID uuid.UUID, mangaID uuid.UUID)) *MockSocialRepository_ToggleFavorite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 uuid.UUID
		if args[2] != nil {
			arg2 = args[2].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSocialRepository_ToggleFavorite_Call) Return(toggleFavoriteResult *repository.ToggleFavoriteResult, err error) *MockSocialRepository_ToggleFavorite_Call {
	_c.Call.Return(toggleFavoriteResult, err)
	return _c
}

func (_c *MockSocialRepository_ToggleFavorite_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID, mangaID uuid.UUID) (*repository.ToggleFavoriteResult, error)) *MockSocialRepository_ToggleFavorite_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) Create(ctx context.Context, user *domain.User) error {
	ret := _mock.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok {
		r0 = returnFunc(ctx, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockUserRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - user *domain.User
func (_e *MockUserRepository_Expecter) Create(ctx interface{}, user interface{}) *MockUserRepository_Create_Call {
	return &MockUserRepository_Create_Call{Call: _e.mock.On("Create", ctx, user)}
}

func (_c *MockUserRepository_Create_Call) Run(run func(ctx context.Context, user *domain.User)) *MockUserRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.User
		if args[1] != nil {
			arg1 = args[1].(*domain.User)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_Create_Call) Return(err error) *MockUserRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_Create_Call) RunAndReturn(run func(ctx context.Context, user *domain.User) error) *MockUserRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// FindByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) FindByEmail(ctx context.Context, email string) (*domain.User, error) {
	ret := _mock.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for FindByEmail")
	}

	var r0 *domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.User, error)); ok {
		return returnFunc(ctx, email)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = returnFunc(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, email)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_FindByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByEmail'
type MockUserRepository_FindByEmail_Call struct {
	*mock.Call
}

// FindByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockUserRepository_Expecter) FindByEmail(ctx interface{}, email interface{}) *MockUserRepository_FindByEmail_Call {
	return &MockUserRepository_FindByEmail_Call{Call: _e.mock.On("FindByEmail", ctx, email)}
}

func (_c *MockUserRepository_FindByEmail_Call) Run(run func(ctx context.Context, email string)) *MockUserRepository_FindByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_FindByEmail_Call) Return(user *domain.User, err error) *MockUserRepository_FindByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepository_FindByEmail_Call) RunAndReturn(run func(ctx context.Context, email string) (*domain.User, error)) *MockUserRepository_FindByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// FindByID provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) FindByID(ctx context.Context, id uuid.UUID) (*domain.User, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for FindByID")
	}

	var r0 *domain.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.User, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.User); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_FindByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByID'
type MockUserRepository_FindByID_Call struct {
	*mock.Call
}

// FindByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockUserRepository_Expecter) FindByID(ctx interface{}, id interface{}) *MockUserRepository_FindByID_Call {
	return &MockUserRepository_FindByID_Call{Call: _e.mock.On("FindByID", ctx, id)}
}

func (_c *MockUserRepository_FindByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockUserRepository_FindByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_FindByID_Call) Return(user *domain.User, err error) *MockUserRepository_FindByID_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepository_FindByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*domain.User, error)) *MockUserRepository_FindByID_Call {
	_c.Call.Return(run)
	return _c
}

// FindDefaultUserRoleID provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) FindDefaultUserRoleID(ctx context.Context) (uuid.UUID, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FindDefaultUserRoleID")
	}

	var r0 uuid.UUID
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (uuid.UUID, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) uuid.UUID); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_FindDefaultUserRoleID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindDefaultUserRoleID'
type MockUserRepository_FindDefaultUserRoleID_Call struct {
	*mock.Call
}

// FindDefaultUserRoleID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockUserRepository_Expecter) FindDefaultUserRoleID(ctx interface{}) *MockUserRepository_FindDefaultUserRoleID_Call {
	return &MockUserRepository_FindDefaultUserRoleID_Call{Call: _e.mock.On("FindDefaultUserRoleID", ctx)}
}

func (_c *MockUserRepository_FindDefaultUserRoleID_Call) Run(run func(ctx context.Context)) *MockUserRepository_FindDefaultUserRoleID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockUserRepository_FindDefaultUserRoleID_Call) Return(uUID uuid.UUID, err error) *MockUserRepository_FindDefaultUserRoleID_Call {
	_c.Call.Return(uUID, err)
	return _c
}

func (_c *MockUserRepository_FindDefaultUserRoleID_Call) RunAndReturn(run func(ctx context.Context) (uuid.UUID, error)) *MockUserRepository_FindDefaultUserRoleID_Call {
	_c.Call.Return(run)
	return _c
}

// GetRoleAndPermissions provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetRoleAndPermissions(ctx context.Context, userID uuid.UUID) (*domain.Role, error) {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetRoleAndPermissions")
	}

	var r0 *domain.Role
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*domain.Role, error)); ok {
		return returnFunc(ctx, userID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *domain.Role); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Role)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetRoleAndPermissions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRoleAndPermissions'
type MockUserRepository_GetRoleAndPermissions_Call struct {
	*mock.Call
}

// GetRoleAndPermissions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
func (_e *MockUserRepository_Expecter) GetRoleAndPermissions(ctx interface{}, userID interface{}) *MockUserRepository_GetRoleAndPermissions_Call {
	return &MockUserRepository_GetRoleAndPermissions_Call{Call: _e.mock.On("GetRoleAndPermissions", ctx, userID)}
}

func (_c *MockUserRepository_GetRoleAndPermissions_Call) Run(run func(ctx context.Context, userID uuid.UUID)) *MockUserRepository_GetRoleAndPermissions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetRoleAndPermissions_Call) Return(role *domain.Role, err error) *MockUserRepository_GetRoleAndPermissions_Call {
	_c.Call.Return(role, err)
	return _c
}

func (_c *MockUserRepository_GetRoleAndPermissions_Call) RunAndReturn(run func(ctx context.Context, userID uuid.UUID) (*domain.Role, error)) *MockUserRepository_GetRoleAndPermissions_Call {
	_c.Call.Return(run)
	return _c
}
